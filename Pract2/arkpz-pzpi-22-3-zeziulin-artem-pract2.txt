Харківський університет радіоелектроніки
Факультет комп'ютерних наук
Кафедра програмної інженерії

ЗВІТ
до практичної роботи номер 2 з дисципліни
"Аналіз та рефакторинг коду"
на тему: "Методи рефакторингу коду програмного забезпечення"

Виконав ст. гр ПЗПІ-22-3
Зезюлін Артем Віталійович

Перевірив
ст. викладач катедри ПІ
Сокорчук Ігор Петрович

Харків 2024

2

1 МЕТА

Вивчити основні методи рефакторингу коду на основі реальних прикладів з
власних проектів. Навчитися ідентифікувати проблеми в коді та використовувати
відповідні методи рефакторингу для покращення його якості.

2 ВСТУП

Рефакторинг — це процес покращення структури коду без зміни його кінцевої
функціональності.
Мета рефакторингу полягає у підвищенні читаємості коду та спрощенні його
підтримки та спільної роботи над ним.
Рефактринг слід проводити у наступних випадках:
–

Перед додаванням нової функціональності;

–

Після

виправлення

багів

(щоб

уникнути

їхнього

повторного

виникнення);
–

При зростанні складності коду;

–

Під час звичайного огляду коду (якщо помічені недоліки чи порушення

стандартів).
В роботі розглянуто наступні методи рефакторингу:
1. Remove parameter
2. Replace constructor with factory method
3. Pull up method

3

3 ХІД РОБОТИ

Метод: Remove parameter (Видалення зайвого параметру)
Опис: метод «Remove Parameter» полягає у видаленні параметра з методу
чи функції, якщо він більше не використовується. Це трапляється наприклад при
зміні функціональності методу, винесенні цього параметру як константи, або при
зміні структури інших параметрів методу. Видалення в таких випадках цього
зайвого параметру дозволяє підтримувати код чистим та високопродуктивних, а
також запобігає ситуації, коли один параметр протягується через декілька методів
до цільового, в якому потім не використовується. Цей метод також допомагає
дотримуватися принципу програмування KISS (Keep It Simple, Stupid).
Приклад:
// До рефакторингу
public class AccountManager
{
private readonly string _name;
private readonly string _surname;

public AccountManager(string name, string surname)
{
_name = name;
_surname = surname;
}

public void Greetings(string name, string surname)
{
Console.WriteLine($"Hello, {_name} {_surname}!");
}
}

// після рефакторингу
public class AccountManager

4
{
private readonly string _name;
private readonly string _surname;

public AccountManager(string name, string surname)
{
_name = name;
_surname = surname;
}

public void Greetings()
{
Console.WriteLine($"Hello, {_name} {_surname}!");
}
}

Пояснення: раніше, ім’я та фамілія користувача передавалися як параметру
методу

Greetings,

але через подальше розширення функціональності класу,

отримання цих даних було перенесено до конструктору. Через це, отримувати їх як
параметри методу вже не потрібно, отже треба провести рефакторинг та видалити
їх.

Метод: Replace constructor with factory method (Заміна конструктора на
фабричний метод)
Опис: метод «Replace constructor with factory method» полягає в заміні
прямого виклику конструктора класу спеціальним статичним або фабричним
методом, який створює екземпляри цього класу. Він передбачає різні варіанти
реалізації та використовується для підвищення семантики коду (зрозумілі імена
методів), спрощення конструктору та обмеження доступу до нього. Принцип
«Replace constructor with factory method» також є основою для шаблону
програмування Singleton.
Приклад:

5
// До рефакторингу
public class User
{
public string Role { get; private set; }

public User(string role)
{
Role = role;
}
}

public class Program
{
public static void Main(string[] args)
{
var admin = new User("admin");
var guest = new User("guest");
}
}

// після рефакторингу
public class User
{
public string Role { get; private set; }

public User(string role)
{
Role = role;
}

public static User CreateAdmin()
{
return new User("admin");
}

public static User CreateGuest()
{

6
return new User("guest");
}
}

public class Program
{
public static void Main(string[] args)
{
var admin = User.CreateAdmin();
var guest = User.CreateGuest();
}
}

Пояснення: код до рефакторингу передбачав, що програміст пам’ятатиме,
які саме назви якій ролі відповідають, що робить код схильним до помилок,
пов’язаних із неуважністю програміста. Такий код буде також дуже важко
виправляти у випадку зміни назви певної ролі. Тому було проведено рефакторинг,
створення користувача було винесено у фабричні методи. Тепер назви ролей
прописано лише в одному місці. Такий код легко підтримувати, він інтуїтивно
зрозумілий та менше схильний до помилок.

Метод: Pull up method (Підняття методу)
Опис: метод Pull up method полягає у перенесенні методу з підкласів до
батьківського класу, якщо ці підкласи мають однакову реалізацію методу. Це
дозволяє спростити підтримку коду та усунути його дублювання, допомагаючи
програмісту відповідати принципу DRY (Don't Repeat Yourself).
Приклад:
// До рефакторингу
public abstract class AppUser
{
public virtual string Role { get; }
}

7
public class Admin : AppUser
{
public override string Role { get => "Admin"; }

public void Greet(string name)
{
Console.WriteLine($"Hello, Admin {name}");
}
}

public class GenericUser : AppUser
{
public override string Role { get => "User"; }

public void Greet(string name)
{
Console.WriteLine($"Hello, User {name}");
}
}

// після рефакторингу
public abstract class AppUser
{
public virtual string Role { get; }

public void Greet(string name)
{
Console.WriteLine($"Hello, {Role} {name}");
}
}

public class Admin : AppUser
{
public override string Role { get => "Admin"; }
}

public class GenericUser : AppUser

8
{
public override string Role { get => "User"; }
}

Пояснення: метод

Greet

класів Admin та

GenericUser

виконує одну і ту саму

функціональність, тому, заради запобігання повторення коду, треба провести
рефакторинг та винести цей метод до спільного між ними батьківського класу
AppUser.

9

3 ІНСТРУМЕНТИ РЕФАКТОРИНГУ

Найбільш розповсюдженими інструментами для рефакторингу коду є
інтегровані середи розробки (IDE) – вони зазвичай не потребують додаткового
налаштування та пропонують широкий спектр функцій для автоматизації та
спрощення рефакторингу. Найбільш популярними серед них є:
–

JetBrains IDE (IntelliJ IDEA, PyCharm, Rider, CLion):
o Мови програмування: Java, Python, C#, C++, JavaScript та інші;
o Автоматизовані операції: перейменування змінних, методів та
класів; переміщення методів та класів; заміна конструктору
фабричним методом та ін.;

–

Visual Studio
o Мови програмування: C#, F#,C++, Python та інші;
o Автоматизовані операції: перейменування змінних, методів та
класів; інкапсуляція полів; видалення та додавання параметрів у
метод та ін.;

–

Eclipse
o Мови програмування: Java, C++, Python;
o Автоматизовані операції: винесення фрагменту коду в окремий
метод; інкапсуляція полів; видалення та додавання параметрів у
метод та ін.;

–

Visual Studio Code
o Мови програмування: Java, Python, C, C#, C++, JavaScript, PHP та
інші;
o Автоматизовані операції: залежить від встановлених плагінів;

–

NetBeans
o Мови програмування: Java, C++, PHP та інші;
o Автоматизовані операції: перейменування змінних, методів та
класів; винесення фрагменту коду в окремий метод та ін.

10

Інші інструменти для рефакторингу коду включають плагіни до IDE, плагіни
для автоматичного аналізу коду та автоматичного рефакторингу. Як інструмент
рефакторингу можна також відмітити освітні ресурси, книжки та довідники,
присвячені рефакторингу – вони допоможуть у розв’язанні більш складних та
нестандартних проблем.

11

ВИСНОВКИ

В ході виконання практичної роботи було проведено дослідження таких трьох
методів рефакторингу, як Remove parameter (Видалення зайвого параметру),
Replace constructor with factory method (Заміна конструктора на фабричний метод)
та Pull up method (Підняття методу). Ці методи було також примінено на реальному
коді.
В ході виконання практичної роботи було також виконано короткий огляд
популярних інструментів рефакторингу.

12

ДОДАТОК А
СПИСОК ВИКОРИСТАНИХ ДЖЕРЕЛ

1. Martin Fowler. Refactoring. Improving the Design of Existing Code– AddisonWesley Professional, 1999. – 464 p.

13

ДОДАТОК Б
ПОСИЛАННЯ НА ВІДЕО НА YOUTUBE

https://youtu.be/HWPEf4z1DRs

14

ДОДАТОК В
ПРЕЗЕНТАЦІЯ

15

16

17

18

19

20

21

